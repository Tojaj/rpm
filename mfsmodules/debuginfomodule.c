#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpm/rpmlog.h>
#include <rpm/rpmlib.h>
#include <rpm/rpmstring.h>
#include "build/mfs.h"

#define FINDDEBUGINFO "%{_rpmconfigdir}/find-debuginfo.sh "\
	    "%{?_missing_build_ids_terminate_build:--strict-build-id} "\
	    "%{?_include_minidebuginfo:-m} "\
	    "%{?_find_debuginfo_dwz_opts} "\
	    "%{?_find_debuginfo_opts} \"%{_builddir}/%{?buildsubdir}\" %{nil}"

typedef struct SharedData_s {
    MfsPackage pkg;
} * SharedData;

rpmRC setupPkgFunc(MfsContext context)
{
    rpmRC rc = RPMRC_FAIL;
    MfsSpec spec = mfsContextGetSpec(context);
    MfsBTScript install_script = NULL;
    char *arch = mfsSpecGetArch(spec);
    char *code;
    char *expanded;
    int debugpackage = 1;

    if (!spec) {
	mfslog_err("Cannot get spec from context\n");
	goto exit;
    }

    // Check if the debuginfo should be created

    // Check arch of the package
    if (arch && !strcmp(arch, "noarch")) {
	mfslog_info("Debuginfo subpackage won't be generated by module - noarch package\n");
	debugpackage = 0;  // Don't do debuinfo package for noarch packages
    }
    free(arch);

    // Check if script for stripping isn't already used
    install_script = mfsSpecGetScript(spec, MFS_SPEC_SCRIPT_INSTALL);
    code = mfsBTScriptGetCode(install_script);
    if (code) {
	expanded = rpmExpand("%{_rpmconfigdir}/find-debuginfo.sh", NULL);
	if (strstr(code, expanded) != NULL) {
	    // find-debuginfo.sh script is already used in install script
	    mfslog_info("Debuginfo subpackage won't be generated by module - "
		    "find-debuginfo.sh is already used in %install\n");
	    debugpackage = 0;
	}
	free(expanded);
	free(code);
    }

    if (debugpackage) {
	MfsPackage pkg = NULL;
	MfsFileLines flines;
	MfsFileFiles ffiles;

	// Strip debuginfo and gen filelist of stripped files
	expanded = rpmExpand(FINDDEBUGINFO, NULL);
	mfsBTScriptAppendLine(install_script, expanded);
	free(expanded);
	mfsSpecSetScript(spec, install_script, MFS_SPEC_SCRIPT_INSTALL);

	// Prepare subpackage
	mfslog_info("Adding debuginfo subpackage\n");
	pkg = mfsPackageNew(context, "debuginfo2",
			    "Debug information for package %{name}",
			    MFS_PACKAGE_FLAG_SUBNAME);
	if (!pkg)
	    goto exit;

	mfsPackageSetDescription(pkg,
	    "This package provides debug information for package %{name}.\n"
	    "Debug information is useful when developing applications that use this\n"
	    "package or when debugging this package.\n", NULL);
	mfsPackageSetTag(pkg, RPMTAG_GROUP, "Development/Debug", NULL);
	mfsPackageSetTag(pkg, RPMTAG_AUTOREQPROV, "0", NULL);

	if (mfsPackageFinalize(pkg) != RPMRC_OK)
	    goto exit;

	flines = mfsPackageGetFileLines(pkg);
	mfsFileLinesAppend(flines, "%defattr(-,root,root)");
	mfsPackageSetFileLines(pkg, flines);
	mfsFileLinesFree(flines);

	ffiles = mfsPackageGetFileFiles(pkg);
	mfsFileFilesAppend(ffiles, "debugfiles.list");
	mfsPackageSetFileFiles(pkg, ffiles);
	mfsFileFilesFree(ffiles);

	// Prepare context (spec) related data
        SharedData data = calloc(1, sizeof(*data));
        data->pkg = pkg;
        mfsContextSetData(context, data);
    }

    rc = RPMRC_OK;

exit:
    mfsBTScriptFree(install_script);
    mfsSpecFree(spec);
    return rc;
}

rpmRC finalFunc(MfsContext context)
{
    SharedData data = mfsContextGetData(context);
    if (data) {
	mfsPackageFree(data->pkg);
        free(data);
    }
    return RPMRC_OK;
}

rpmRC init_debuginfomodule(MfsManager mm)
{
    MfsBuildHook buildhook;

    buildhook = mfsBuildHookNew(setupPkgFunc, MFS_HOOK_POINT_POSTPARSE);
    mfsBuildHookSetPrettyName(buildhook, "setupPkgFunc()");
    mfsManagerRegisterBuildHook(mm, buildhook);

    buildhook = mfsBuildHookNew(finalFunc, MFS_HOOK_POINT_FINAL);
    mfsBuildHookSetPrettyName(buildhook, "finalFunc()");
    mfsManagerRegisterBuildHook(mm, buildhook);

    return RPMRC_OK;
}
